Robert Griffith
304 833 256

[Gather Instruction Traces]
input:	gdb ~eggert/bin64/bin/emacs-25.2
output:	...
		Reading symbols from w/fac.2/cs/eggert/bin64/bin/emacs-25.2...done.
result:	I entered GDB and the symbols from w/fac.2/cs/eggert/bin64/bin/emacs-25.2 were loaded so functions like Ftimes would be defined. 

input:	trace Ftimes
output:	Tracepoint 1 at 0x547ad0: file data.c, line 2815.
result:	A tracepoint was placed on the function Ftimes, which lies in the file data.c at line 2815.

input:	set disassemble-next-line on
result:	This will disassemble all code showed by the breakpoints, showing assembly code.

input:	set logging file trace.tr
input:	set logging on
output:	Copying output to trace.tr.
result:	GDB will now print trace dumps into file named trace.tr instead of just printing it out in terminal.

input:	Q -batch -eval '(print (* 1250284240 -1844255039))'
output:	No symbol "batch" in current context.
result:	This was an unsuccessful command.

input:	help Q
output:	Exit gdb
result:	The command Q is apparently used to quit gdb, so trying to perform the operation with Q didn't make sense.
		I then looked to the GDB guide and tried using the R command to run a program

input:	R -batch -eval '(print (* 1250284240 -1844255039))'
output:	Starting program ...
		...
		-814871532345840
		[Thread 0x7fffe3174700 (LWP 46976)]
		[Inferior 1 (process 46972) exited normally]
		Missing separate debuginfors, use: debuginfo-install ...
		...
result:	I exited the terminal and did more research into tracepoints, and to get the assembly code I want, I need to use breakpoints not tracepoints.
	I also realized I need the -Q operator after R.

input:	gdb ~eggert/bin64/bin/emacs-25.2

input:	break Ftimes
output:	Breakpoint 1 at 0x547ad0: file data.c, line 2815.
result:	After deleting the tracepoint and clearing trace.tr, I put a breakpoint at Ftimes instead of tracepoint.

input:	set disassemble-next-line on

input:	set logging file trace.tr
input:	set logging on
output:	Copying output to trace.tr.

input:	R -Q -batch -eval '(print (* 1250284240 -1844255039))'
From this point on all output can be found in trace.tr

input:	info registers
input:	si
result:	I repeatedly use these commands to step through Ftimes and have the assembly code and register values recorded in trace.tr.

input:	c
result:	The program continues and does not write the rest of the assembly codes to trace.tr.

[Examine Integer Overflow Handling]
Within sublime text editor I first created testovf.c, a c file containing the function testovf as defined in the lab spec.

input:	gcc -S -O2 testovf.c -o testovfO2.s
result:	I created an assembly file named testovfO2.s from testovf.c with optimization of level 2.

input:	gcc -S -O2 -fwrapv testovf.c -o testovfO2fwrapv.s
result:	I created an assembly file named testovfO2fwrapv.s from testovf.c with optimization of level 2 and signed integer overflow defined to wrap around.

input:	gcc -S -O2 -fsanitize=undefined testovf.c -o testovfO2sanitize.s
result:	I created an assembly file named testovfO2sanitize.s from testovf.c with optimization of level 2 and the machine code compiled from this would give runtime errors for signed integer overflow.

[A Few More Questions]
1.
There were no inputs; I just looked at the trace and researched how Elisp stores/recognizes ints.

2.
There were no inputs; I just used knowledge of how Elisp stores ints and calculated what the minimum signed value int would be.

3.
Again, there were no inputs; I just used knowledge of how Elisp stores, multiplies, and returns values.

4.
I researched into emacs, and discovered that the arthetic used is all automatically wrapping around with overflow.

5.
input:	gdb ~eggert/bin64/bin/emacs-25.2
		set logging file backtrace.txt
		set logging on
inupt:	R -Q -batch -eval '(print (format-time-string "%Y-%m-%d %H:%M:%S %Z" nil (concat (make-string 1000 ?X) "0")))'
output:	...
		Program received signal SIGSEGV, Segmentation fault.
		...
result:	There was a segmentation fault, bad memory was accessed

input:	bt full
result:	I did a full backtrace of the stack, showing what was called and in what order. 
		This also would give me some values of some variables.

I repeated the above process, logging to a new file named btassembly.txt and setting disassemble-next-line on in order to get a trace of the assembly code, I did not do a full backtrace, only bt.

input:	b __strcpy_sse2_unaligned
output:	Breakpoint 1 at 0x7ffff1739300
result:	breakpoint set at strcpy_sse2_unaligned

input:	set logging off
		set logging file strcpy_sse2.txt
		set logging on
		set disassemble-next-line on
		R -Q -batch -eval '(print (format-time-string "%Y-%m-%d %H:%M:%S %Z" nil (concat (make-string 1000 ?X) "0")))'

I proceeded to trace through the file using si to step through, x/s *0x-------- to check a string in an adress, print /x $[register name] to check a register's value, and info registers to check the value of multiple registers.
This was done until the program crashed, and I was able to trace the copying of Xs into memory and where the program tried to write to inacessible memory.

With these inputs and outside research question 5 was completed.
